<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VOR Rehab — WebGazer Integration (calibración + puntero + CSV)</title>
  <style>
    :root{ --panel:#0f1724; --glass:rgba(255,255,255,0.03); --accent:#3bd371;}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071029,#0b1020);font-family:Inter,Roboto,system-ui;color:#e6eef8}
    #app{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box}
    #left{flex:1;position:relative;border-radius:12px;overflow:hidden;background:var(--panel);box-shadow:0 6px 30px rgba(0,0,0,0.6)}
    canvas{width:100%;height:100%;display:block;background:#04101b}
    #hud{position:absolute;left:12px;top:12px;z-index:40;background:var(--glass);padding:10px;border-radius:10px;backdrop-filter:blur(6px)}
    #controls{width:400px;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.02));box-shadow:0 6px 18px rgba(0,0,0,0.6)}
    button, select{display:inline-block;margin:6px 6px 6px 0;padding:8px 10px;border-radius:8px;border:none;background:#0b2340;color:#bfe7c8;cursor:pointer}
    .small{font-size:13px;opacity:0.9}
    .status{margin-top:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}
    #logArea{max-height:220px;overflow:auto;font-size:12px;background:rgba(255,255,255,0.02);padding:8px;margin-top:8px;border-radius:8px}
    .bigbtn{padding:10px 14px;font-weight:700;background:#0c2b4a}
    label{display:inline-flex;align-items:center;gap:8px}
  </style>
</head>
<body>
  <div id="app">
    <div id="left">
      <canvas id="scene" width="800" height="600"></canvas>
      <div id="hud">
        <div><strong>VOR Rehab — WebGazer.js</strong></div>
        <div class="small">Estado cámara/tracker: <span id="camStatus">apagada</span></div>
        <div class="status">Predicción (gaze): <span id="gazePos">-</span> | Error actual: <span id="gazeErr">-</span></div>
        <div class="status">HeadVel: <span id="headVel">0</span> px/s | EyeVel: <span id="eyeVel">0</span> px/s</div>
        <div class="status small">Calibración: <span id="calStatus">NO</span></div>
      </div>
    </div>

    <div id="controls">
      <div><strong>Controles</strong></div>
      <div style="margin-top:8px;">
        <button id="startWG" class="bigbtn">Iniciar WebGazer</button>
        <button id="stopWG">Detener WebGazer</button>
        <label style="float:right"><input type="checkbox" id="mirrorToggle"> Espejar vista</label>
      </div>

      <div style="margin-top:12px;">
        <strong>Calibración (9 puntos)</strong>
        <div class="small">Pulsa "Iniciar calibración", mira el punto grande y haz click en el canvas cuando lo veas fijamente. Repite el número de clics por punto.</div>
        <div style="margin-top:8px;">
          <button id="startCal">Iniciar calibración</button>
          <button id="finishCal">Finalizar calibración</button>
          <select id="clicksPerPoint"><option value="3">3 clicks/pt</option><option value="5" selected>5 clicks/pt</option><option value="7">7 clicks/pt</option></select>
        </div>
        <div class="status small">Progreso: <span id="calProgress">0 / 9</span> puntos completados</div>
      </div>

      <div style="margin-top:12px;">
        <strong>Ejercicios</strong>
        <div style="margin-top:8px;">
          <button id="exercise1">Ejercicio 1: Estabilización</button>
          <button id="exercise2">Ejercicio 2: Objetivo móvil</button>
          <button id="stopExercise">Detener ejercicio</button>
        </div>
      </div>

      <div style="margin-top:12px;">
        <strong>Logs</strong>
        <div style="margin-top:8px;">
          <button id="downloadLog">Descargar CSV</button>
          <button id="clearLog">Limpiar log</button>
        </div>
        <div id="logArea"></div>
      </div>

      <footer style="margin-top:10px;font-size:12px;opacity:0.85">
        Tecnologías: <strong>WebGazer.js</strong> (usa trackers internamente), Canvas2D. Recomendado probar en Chrome/Edge con buena iluminación.
      </footer>
    </div>
  </div>

  <!-- WebGazer (Brown Univ.) -->
  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>

  <script>
  /********************************************************************
   * VOR Rehab — WebGazer-based demo
   * - Uses webgazer.begin() + setGazeListener
   * - 9-point calibration: we explicitly call webgazer.recordScreenPosition(x,y,"click")
   * - Adds a gaze pointer (arrow) from face center (if available) to gaze point
   * - CSV log includes gazeX, gazeY, err
   ********************************************************************/

  const canvas = document.getElementById('scene');
  const ctx = canvas.getContext('2d');
  const rect = () => canvas.getBoundingClientRect();

  // UI elements
  const startWG = document.getElementById('startWG'), stopWG = document.getElementById('stopWG');
  const camStatus = document.getElementById('camStatus');
  const gazePosEl = document.getElementById('gazePos'), gazeErrEl = document.getElementById('gazeErr');
  const headVelEl = document.getElementById('headVel'), eyeVelEl = document.getElementById('eyeVel');
  const calStatusEl = document.getElementById('calStatus'), calProgressEl = document.getElementById('calProgress');
  const startCalBtn = document.getElementById('startCal'), finishCalBtn = document.getElementById('finishCal');
  const clicksPerPointSel = document.getElementById('clicksPerPoint');
  const mirrorToggle = document.getElementById('mirrorToggle');

  const downloadLogBtn = document.getElementById('downloadLog'), clearLogBtn = document.getElementById('clearLog');

  let mirrored = false;
  let webgazerRunning = false;
  let lastGaze = null; // {x,y,elapsed}
  let lastHeadCenter = null; // {x,y}
  let lastTimestamp = null;
  let gazeSamples = []; // for smoothing if needed
  let log = [];

  // calibration grid (9 points) in canvas pixel coords
  const gridPercents = [
    [0.08,0.08],[0.5,0.08],[0.92,0.08],
    [0.08,0.5],[0.5,0.5],[0.92,0.5],
    [0.08,0.92],[0.5,0.92],[0.92,0.92]
  ];
  let calPoints = gridPercents.map(p => ({x: Math.round(p[0]*canvas.width), y: Math.round(p[1]*canvas.height)}));
  let calActive = false;
  let currentCalIndex = 0;
  let clicksNeeded = parseInt(clicksPerPointSel.value,10);
  let clicksCount = 0;
  let completedPoints = 0;
  const completedPerPoint = Array(9).fill(0);

  // exercise state
  let currentExercise = null;
  let exerciseState = {};

  // helper: draw arrow from (x0,y0) to (x1,y1)
  function drawArrow(x0,y0,x1,y1,opts={color:'rgba(255,255,0,0.9)', width:3}) {
    const dx = x1-x0, dy = y1-y0;
    const ang = Math.atan2(dy,dx);
    ctx.strokeStyle = opts.color; ctx.fillStyle = opts.color; ctx.lineWidth = opts.width;
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
    // arrowhead
    const ah = 10;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x1 - ah*Math.cos(ang - Math.PI/6), y1 - ah*Math.sin(ang - Math.PI/6));
    ctx.lineTo(x1 - ah*Math.cos(ang + Math.PI/6), y1 - ah*Math.sin(ang + Math.PI/6));
    ctx.closePath(); ctx.fill();
  }

  // logging
  function pushLog(entry){
    log.push(entry);
    const div = document.createElement('div');
    div.textContent = `${new Date(entry.t).toISOString()} | tgt:${entry.tgtX?.toFixed(1)??'-'},${entry.tgtY?.toFixed(1)??'-'} | gaze:${entry.gazeX?.toFixed(1)??'-'},${entry.gazeY?.toFixed(1)??'-'} | err:${(entry.err!==undefined)?entry.err.toFixed(1):'-'}`;
    const area = document.getElementById('logArea');
    area.prepend(div);
    if(area.childElementCount>200) area.removeChild(area.lastChild);
  }

  downloadLogBtn.addEventListener('click', ()=>{
    if(log.length===0){ alert('No hay datos para descargar.'); return; }
    const header = 'timestamp,tgtX,tgtY,gazeX,gazeY,err,headV,eyeV,success\n';
    const rows = log.map(r=>`${new Date(r.t).toISOString()},${r.tgtX??''},${r.tgtY??''},${r.gazeX??''},${r.gazeY??''},${r.err??''},${r.headV??''},${r.eyeV??''},${r.success?1:0}`).join('\n');
    const blob = new Blob([header + rows], {type:'text/csv'});
    const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'vor_webgazer_log.csv'; a.click(); URL.revokeObjectURL(url);
  });

  clearLogBtn.addEventListener('click', ()=>{ log = []; document.getElementById('logArea').innerHTML = ''; });

  // start / stop webgazer
  startWG.addEventListener('click', async ()=>{
    if(webgazerRunning){ alert('WebGazer ya iniciado.'); return; }
    // configure webgazer
    try {
      // choose commonly used regression and tracker for stability
      webgazer.setRegression('ridge');
      webgazer.setTracker('clmtrackr'); // clmtrackr will provide face positions (if available)
    } catch(e){ console.warn('No pudo setear opciones (version de webgazer).', e); }
    // hide built-in prediction dot (we handle custom drawing)
    try { webgazer.showPredictionPoints(false); } catch(e){}
    // begin
    webgazer.begin()
      .then(()=> {
        webgazerRunning = true;
        camStatus.textContent = 'iniciada';
        console.log('WebGazer begin.');
      })
      .catch(err=>{
        alert('No se pudo iniciar WebGazer: ' + err);
      });

    // set gaze listener (fires often)
    webgazer.setGazeListener(function(data, elapsedTime) {
      // data: {x: <pageX>, y: <pageY>} - x,y are page coordinates
      if(!data) return;
      // convert page coords to canvas coords
      const r = rect();
      // page -> canvas coordinates: subtract left/top and scale to canvas resolution
      // handle canvas CSS scaling
      const scaleX = canvas.width / r.width;
      const scaleY = canvas.height / r.height;
      let pageX = data.x, pageY = data.y;
      // webgazer returns coordinates relative to viewport: data.x, data.y
      // compute canvas-relative coords
      let cx = (pageX - r.left) * scaleX;
      let cy = (pageY - r.top) * scaleY;
      if(mirrored) cx = canvas.width - cx;
      lastGaze = { x: cx, y: cy, elapsed: elapsedTime };
      // smoothing buffer (optional)
      gazeSamples.push([cx,cy]);
      if(gazeSamples.length > 5) gazeSamples.shift();
      // compute smoothed
      const avg = gazeSamples.reduce((a,b)=>[a[0]+b[0], a[1]+b[1]],[0,0]).map(v=>v/gazeSamples.length);
      lastGaze.smoothedX = avg[0]; lastGaze.smoothedY = avg[1];
    });

    // ensure we can get tracker for head center
    // (we'll try to use webgazer.getTracker().getCurrentPosition())
    // nothing else to do now; drawing happens in animation loop
  });

  stopWG.addEventListener('click', ()=>{
    try { webgazer.end(); } catch(e){ console.warn('webgazer.end error', e); }
    webgazerRunning = false;
    camStatus.textContent = 'detenida';
  });

  // Calibration controls
  startCalBtn.addEventListener('click', ()=>{
    if(!webgazerRunning){ alert('Inicia WebGazer antes de calibrar.'); return; }
    calActive = true;
    currentCalIndex = 0;
    clicksCount = 0;
    completedPoints = 0;
    completedPerPoint.fill(0);
    calStatusEl.textContent = 'EN PROGRESO';
    calProgressEl.textContent = `${completedPoints} / 9`;
    clicksNeeded = parseInt(clicksPerPointSel.value,10);
    alert('Calibración iniciada: mira el punto grande y haz click en el canvas cuando lo veas fijamente. Repite para los ' + clicksNeeded + ' clicks por punto.');
  });

  finishCalBtn.addEventListener('click', ()=>{
    calActive = false;
    calStatusEl.textContent = 'COMPLETADA';
    alert('Calibración finalizada. WebGazer habrá usado los clicks para actualizar el modelo.');
  });

  // canvas click handler -> used for calibration and exercises clicking if wanted
  canvas.addEventListener('click', (ev)=>{
    const r = rect();
    const scaleX = canvas.width / r.width, scaleY = canvas.height / r.height;
    const cx = (ev.clientX - r.left) * scaleX;
    const cy = (ev.clientY - r.top) * scaleY;
    if(calActive){
      // record click for current cal point
      const pt = calPoints[currentCalIndex];
      // We explicitly register the screen position with webgazer in PAGE coordinates.
      // Convert canvas pt back to page coordinates (approximate center)
      const pageX = r.left + (pt.x / canvas.width) * r.width;
      const pageY = r.top + (pt.y / canvas.height) * r.height;
      try{
        if(typeof webgazer.recordScreenPosition === 'function'){
          webgazer.recordScreenPosition(pageX, pageY, 'click');
        } else if (typeof webgazer.calibratePoint === 'function'){
          // jsPsych wrappers might expose calibratePoint
          webgazer.calibratePoint(pageX, pageY);
        } else {
          // fallback: simulate click event at page coords so webgazer core picks it up
          const e = new MouseEvent('click',{clientX: pageX, clientY: pageY, bubbles:true, cancelable:true});
          window.dispatchEvent(e);
        }
      }catch(e){
        console.warn('No se pudo enviar punto de calibración explicitamente: ', e);
      }
      clicksCount++;
      completedPerPoint[currentCalIndex] = clicksCount;
      if(clicksCount >= clicksNeeded){
        // move to next point
        clicksCount = 0;
        currentCalIndex++;
        completedPoints++;
        calProgressEl.textContent = `${completedPoints} / 9`;
        if(currentCalIndex >= calPoints.length){
          // done
          calActive = false;
          calStatusEl.textContent = 'COMPLETADA';
          alert('Calibración completa (9 puntos). Puedes ajustar y repetir si querés más precisión.');
        }
      }
    } else {
      // could capture ad-hoc clicks as calibration points (optional behavior)
      try{
        const pageX = ev.clientX, pageY = ev.clientY;
        if(webgazer && typeof webgazer.recordScreenPosition === 'function'){
          webgazer.recordScreenPosition(pageX, pageY, 'click');
        }
      }catch(e){}
    }
  });

  // mirror toggle
  mirrorToggle.addEventListener('change', (e)=>{ mirrored = e.target.checked; });

  // Exercises
  document.getElementById('exercise1').addEventListener('click', ()=>startExercise('stabilize'));
  document.getElementById('exercise2').addEventListener('click', ()=>startExercise('moving'));
  document.getElementById('stopExercise').addEventListener('click', stopExercise);

  function startExercise(name){
    if(!webgazerRunning){ alert('Inicia WebGazer antes de arrancar ejercicios.'); return; }
    currentExercise = name;
    exerciseState = { startedAt: performance.now(), difficulty: 1.0, succesBuffer: [], tgt: null };
  }
  function stopExercise(){ currentExercise = null; exerciseState = {}; }

  // evaluation helper
  function evaluateSuccess(gx,gy,tx,ty,allowedPx){
    const dx = gx - tx, dy = gy - ty;
    const err = Math.hypot(dx,dy);
    return {err, success: err <= allowedPx};
  }

  // main render loop
  function renderLoop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // draw background subtle grid
    ctx.fillStyle = '#04101b'; ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw calibration target if active
    if(calActive){
      const idx = Math.min(currentCalIndex, calPoints.length-1);
      const p = calPoints[idx];
      // draw all points small
      for(let i=0;i<calPoints.length;i++){
        const q = calPoints[i];
        ctx.beginPath(); ctx.arc(q.x,q.y,6,0,Math.PI*2);
        ctx.fillStyle = completedPerPoint[i] >= clicksNeeded ? 'rgba(0,180,120,0.9)' : 'rgba(255,255,255,0.18)';
        ctx.fill();
      }
      // draw big pulsing point for current
      const pulse = 6 + (Math.sin(Date.now()/250)*4);
      ctx.beginPath(); ctx.arc(p.x,p.y, 18 + Math.abs(pulse), 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,120,40,0.95)'; ctx.fill();
      ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.stroke();
    }

    // if we have a last gaze prediction, draw pointer and marker
    if(lastGaze){
      const gx = lastGaze.smoothedX ?? lastGaze.x, gy = lastGaze.smoothedY ?? lastGaze.y;
      // draw gaze dot
      ctx.beginPath(); ctx.arc(gx, gy, 8, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,0,0.9)'; ctx.fill();

      // compute origin for arrow: try to use face center from webgazer tracker
      let origin = {x: canvas.width*0.5, y: canvas.height*0.8}; // fallback (bottom-center)
      try{
        const tracker = webgazer.getTracker && webgazer.getTracker();
        if(tracker && typeof tracker.getCurrentPosition === 'function'){
          const pos = tracker.getCurrentPosition(); // array of points in video coords (x,y)
          if(pos && pos.length){
            // compute avg of pos points to approximate face center
            let sx=0, sy=0, n=0;
            for(const p of pos){
              if(!p) continue;
              sx += p[0]; sy += p[1]; n++;
            }
            if(n>0){
              // pos values are relative to the webgazer video element size.
              // Map them into canvas coordinates approximately:
              // webgazer default video overlay is positioned in the page; we approximate mapping by transforming video coords proportionally
              const overlay = document.getElementById('webgazerVideoContainer') || document.querySelector('video');
              if(overlay){
                const vr = overlay.getBoundingClientRect();
                const c = rect();
                const scaleX = canvas.width / c.width;
                const scaleY = canvas.height / c.height;
                const avgx = (sx / n);
                const avgy = (sy / n);
                // avgx/avgy are in video pixels relative to video's top-left (in page coordinates)
                // we compute page coords approx = vr.left + avgx*(vr.width/videoWidth)
                const px = vr.left + (avgx / (overlay.videoWidth || vr.width)) * vr.width;
                const py = vr.top  + (avgy / (overlay.videoHeight || vr.height)) * vr.height;
                // map to canvas coords
                let ox = (px - c.left) * scaleX;
                let oy = (py - c.top)  * scaleY;
                if(mirrored) ox = canvas.width - ox;
                // sanity check
                if(!isNaN(ox) && !isNaN(oy)){
                  origin = {x: ox, y: oy};
                }
              }
            }
          }
        }
      }catch(e){ /* ignore tracker errors */ }

      // draw arrow from origin to gaze
      drawArrow(origin.x, origin.y, gx, gy, {color:'rgba(120,220,255,0.95)', width:3});

      // HUD update
      gazePosEl.textContent = `${Math.round(gx)}, ${Math.round(gy)}`;

      // run exercise logic if active
      if(currentExercise === 'stabilize'){
        runStabilize({gazeX: gx, gazeY: gy});
      } else if(currentExercise === 'moving'){
        runMoving({gazeX: gx, gazeY: gy});
      }
    } else {
      gazePosEl.textContent = '-';
    }

    requestAnimationFrame(renderLoop);
  }

  requestAnimationFrame(renderLoop);

  // --- Exercises implementations (same ideas, adapted to use gazeX/gazeY) ---
  function runStabilize(sensors){
    const now = performance.now();
    if(!exerciseState.tgt){ exerciseState.tgt = {x: canvas.width*0.5, y: canvas.height*0.45}; exerciseState.lastHead = {x: canvas.width*0.5, y: canvas.height*0.5}; exerciseState.allowedPx = 60; exerciseState.successBuffer = []; }
    // approximate head movement via tracker center fallback to zero
    let head = exerciseState.lastHead;
    try{
      const tracker = webgazer.getTracker && webgazer.getTracker();
      if(tracker && tracker.getCurrentPosition){
        const pos = tracker.getCurrentPosition();
        if(pos && pos.length){
          let sx=0, sy=0, n=0;
          for(const p of pos){ if(!p) continue; sx += p[0]; sy += p[1]; n++; }
          if(n>0){
            // map approximate to canvas using screen rect (as in render)
            const overlay = document.querySelector('video');
            if(overlay){
              const vr = overlay.getBoundingClientRect();
              const c = rect();
              const scaleX = canvas.width / c.width, scaleY = canvas.height / c.height;
              const avgx = sx/n, avgy = sy/n;
              const px = vr.left + (avgx / (overlay.videoWidth || vr.width)) * vr.width;
              const py = vr.top  + (avgy / (overlay.videoHeight || vr.height)) * vr.height;
              let hx = (px - c.left) * scaleX, hy = (py - c.top) * scaleY;
              if(mirrored) hx = canvas.width - hx;
              head = {x: hx, y: hy};
            }
          }
        }
      }
    }catch(e){ /* ignore */ }

    // head delta
    const hx = head.x - exerciseState.lastHead.x; const hy = head.y - exerciseState.lastHead.y;
    const scale = 0.8 * exerciseState.difficulty;
    exerciseState.tgt.x -= hx * scale; exerciseState.tgt.y -= hy * scale;
    exerciseState.tgt.x = Math.max(40, Math.min(canvas.width-40, exerciseState.tgt.x));
    exerciseState.tgt.y = Math.max(40, Math.min(canvas.height-40, exerciseState.tgt.y));
    exerciseState.lastHead = head;

    // draw target
    ctx.beginPath(); ctx.arc(exerciseState.tgt.x, exerciseState.tgt.y, 18, 0, Math.PI*2); ctx.fillStyle='rgba(30,200,120,0.9)'; ctx.fill();

    const ev = evaluateSuccess(sensors.gazeX, sensors.gazeY, exerciseState.tgt.x, exerciseState.tgt.y, exerciseState.allowedPx);
    gazeErrEl.textContent = ev.err.toFixed(1);

    exerciseState.successBuffer.push(ev.success?1:0); if(exerciseState.successBuffer.length>60) exerciseState.successBuffer.shift();
    const srate = exerciseState.successBuffer.reduce((a,b)=>a+b,0)/exerciseState.successBuffer.length;

    // adapt difficulty
    if(!exerciseState.lastAdjust) exerciseState.lastAdjust = now;
    if(now - exerciseState.lastAdjust > 2000){
      exerciseState.lastAdjust = now;
      if(srate > 0.8) exerciseState.difficulty = Math.min(2.5, exerciseState.difficulty * 1.08);
      else if(srate < 0.4) exerciseState.difficulty = Math.max(0.5, exerciseState.difficulty * 0.94);
    }

    // ring feedback
    ctx.lineWidth = 3;
    ctx.strokeStyle = ev.success ? 'rgba(0,255,120,0.9)' : (ev.err < exerciseState.allowedPx*1.5 ? 'rgba(255,200,0,0.9)' : 'rgba(255,80,80,0.9)');
    ctx.beginPath(); ctx.arc(exerciseState.tgt.x, exerciseState.tgt.y, 28, 0, Math.PI*2); ctx.stroke();

    // log sample (ensure gazeX,gazeY,err are included)
    pushLog({
      t: Date.now(),
      tgtX: exerciseState.tgt.x, tgtY: exerciseState.tgt.y,
      gazeX: sensors.gazeX, gazeY: sensors.gazeY,
      err: ev.err, headV: 0, eyeV: 0, success: ev.success
    });
  }

  function runMoving(sensors){
    const now = performance.now();
    if(!exerciseState.tgt){ exerciseState.tgt = {x:80, y:canvas.height*0.5}; exerciseState.dir = 1; exerciseState.speed = 120; exerciseState.allowedPx = 50; exerciseState.successBuffer = []; }
    const dt = Math.max(1, (now - (exerciseState.lastTick||now)))/1000;
    const sp = exerciseState.speed * (exerciseState.difficulty || 1);
    exerciseState.tgt.x += exerciseState.dir * sp * dt;
    if(exerciseState.tgt.x < 40) { exerciseState.tgt.x = 40; exerciseState.dir = 1; }
    if(exerciseState.tgt.x > canvas.width-40) { exerciseState.tgt.x = canvas.width-40; exerciseState.dir = -1; }
    exerciseState.lastTick = now;

    // draw
    ctx.beginPath(); ctx.arc(exerciseState.tgt.x, exerciseState.tgt.y, 16, 0, Math.PI*2); ctx.fillStyle='rgba(90,170,255,0.95)'; ctx.fill();

    const ev = evaluateSuccess(sensors.gazeX, sensors.gazeY, exerciseState.tgt.x, exerciseState.tgt.y, exerciseState.allowedPx);
    ctx.lineWidth = 3; ctx.strokeStyle = ev.success ? 'rgba(0,255,120,0.9)' : 'rgba(255,80,80,0.9)'; ctx.beginPath(); ctx.arc(exerciseState.tgt.x, exerciseState.tgt.y, 28, 0, Math.PI*2); ctx.stroke();

    exerciseState.successBuffer.push(ev.success?1:0); if(exerciseState.successBuffer.length>80) exerciseState.successBuffer.shift();
    const srate = exerciseState.successBuffer.reduce((a,b)=>a+b,0)/exerciseState.successBuffer.length;
    if(!exerciseState.lastAdjust) exerciseState.lastAdjust = now;
    if(now - exerciseState.lastAdjust > 2000){ exerciseState.lastAdjust = now; if(srate > 0.75) exerciseState.difficulty = Math.min(2.0, exerciseState.difficulty*1.07); else if(srate < 0.35) exerciseState.difficulty = Math.max(0.6, exerciseState.difficulty*0.95); }

    pushLog({
      t: Date.now(),
      tgtX: exerciseState.tgt.x, tgtY: exerciseState.tgt.y,
      gazeX: sensors.gazeX, gazeY: sensors.gazeY,
      err: ev.err, headV: 0, eyeV: 0, success: ev.success
    });
  }

  // small cleanup on unload
  window.addEventListener('beforeunload', ()=>{ try{ webgazer.end(); } catch(e){} });

  // final note: webgazer offers other APIs (getCurrentPrediction, recordScreenPosition)
  // We used recordScreenPosition in calibration clicks to explicitly feed samples to the regression model.
  </script>
</body>
</html>
