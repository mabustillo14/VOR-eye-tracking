<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VOR Rehab — WebGazer integration (Calibración externa)</title>
  <style>
    :root{
      --bg:#071029; --panel:#0f1724; --accent:#3bd371;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071029,#0b1020);font-family:Inter,Roboto,system-ui;color:#e6eef8}
    #app{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box}
    #left{flex:1;position:relative;border-radius:12px;overflow:hidden;background:var(--panel);box-shadow:0 6px 30px rgba(0,0,0,0.6)}
    canvas{width:100%;height:100%;display:block;background:#04101b}
    #hud{position:absolute;left:12px;top:12px;z-index:40;background:rgba(255,255,255,0.03);padding:10px;border-radius:10px;backdrop-filter:blur(6px)}
    #controls{width:420px;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.02));box-shadow:0 6px 18px rgba(0,0,0,0.6)}
    button, select{display:inline-block;margin:6px 6px 6px 0;padding:8px 10px;border-radius:8px;border:none;background:#0b2340;color:#bfe7c8;cursor:pointer}
    .small{font-size:13px;opacity:0.9}
    .status{margin-top:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}
    #logArea{max-height:200px;overflow:auto;font-size:12px;background:rgba(255,255,255,0.02);padding:8px;margin-top:8px;border-radius:8px}
    .bigbtn{padding:10px 14px;font-weight:700;background:#0c2b4a}
    label{display:inline-flex;align-items:center;gap:8px}
  </style>
</head>
<body>
  <div id="app">
    <div id="left">
      <canvas id="scene" width="960" height="600"></canvas>
      <div id="hud">
        <div><strong>VOR Rehab — WebGazer</strong></div>
        <div class="small">WebGazer status: <span id="wgStatus">detenido</span></div>
        <div class="status small">Gaze: <span id="gazePos">-</span> | Error: <span id="gazeErr">-</span></div>
        <div class="status small">Ejercicio: <span id="exerciseLabel">ninguno</span></div>
      </div>
    </div>

    <div id="controls">
      <div><strong>Controles</strong></div>
      <div style="margin-top:8px;">
        <button id="startWG" class="bigbtn">Iniciar WebGazer</button>
        <button id="stopWG">Detener WebGazer</button>
        <label style="float:right"><input type="checkbox" id="mirrorToggle"> Espejar vista</label>
      </div>

      <div style="margin-top:12px;">
        <strong>Calibración</strong>
        <div class="small">Usa la herramienta de calibración oficial (abre en otra pestaña). Recomendado: 9 puntos.</div>
        <div style="margin-top:8px;">
          <button id="openCalib">Abrir WebGazer Calibración</button>
          <button id="useSavedModel">Usar modelo guardado (si existe)</button>
        </div>
        <div class="status small">Nota: la calibración del demo guarda datos en local; si usás la demo y guardás, esta instancia intentará usar esos datos.</div>
      </div>

      <div style="margin-top:12px;">
        <strong>Ejercicios</strong>
        <div style="margin-top:8px;">
          <button id="exercise1">Ejercicio 1: Estabilización</button>
          <button id="exercise2">Ejercicio 2: Objetivo móvil</button>
          <button id="stopExercise">Detener ejercicio</button>
        </div>
      </div>

      <div style="margin-top:12px;">
        <strong>Logs</strong>
        <div style="margin-top:8px;">
          <button id="downloadLog">Descargar CSV</button>
          <button id="clearLog">Limpiar log</button>
        </div>
        <div id="logArea"></div>
      </div>

      <footer style="margin-top:10px;font-size:12px;opacity:0.85">
        Tecnologías: WebGazer.js (usa modelos + media-pipeline internamente), Canvas2D. Calibración externa: webgazer.cs.brown.edu calibration demo.
      </footer>
    </div>
  </div>

  <!-- WebGazer script (oficial) -->
  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>

  <script>
  // ---------- CONFIG & STATE ----------
  const canvas = document.getElementById('scene');
  const ctx = canvas.getContext('2d');
  const wgStatusEl = document.getElementById('wgStatus');
  const gazePosEl = document.getElementById('gazePos');
  const gazeErrEl = document.getElementById('gazeErr');
  const exerciseLabel = document.getElementById('exerciseLabel');
  const mirrorToggle = document.getElementById('mirrorToggle');

  let mirrored = false;
  mirrorToggle.addEventListener('change', ()=> mirrored = mirrorToggle.checked);

  // gaze state updated by webgazer listener
  let latestGaze = null; // {x,y,elapsed}
  let wgRunning = false;
  let log = [];
  let currentExercise = null;
  let exerciseState = {};

  // origin point (virtual eye) for pointer: approx bottom-center of canvas (you can adjust)
  function eyeOrigin(){
    return { x: canvas.width * 0.5, y: canvas.height - 70 };
  }

  // ---------- Start / Stop WebGazer ----------
  document.getElementById('startWG').addEventListener('click', async ()=>{
    try{
      // basic config: show prediction points false (we draw our own), persist model across sessions
      webgazer.setRegression('ridge') // default; options exist
             .setGazeListener(function(data, elapsedTime) {
               if(data == null) return;
               latestGaze = { x: data.x, y: data.y, t: Date.now(), elapsed: elapsedTime };
             })
             .showPredictionPoints(false)
             .saveDataAcrossSessions(true);
      await webgazer.begin();
      // optionally hide default video overlays (webgazer adds video element + canvas to body). hide them to keep UI clean
      webgazer.showVideo(false);
      webgazer.showFaceOverlay(false);
      webgazer.showFaceFeedbackBox(false);
      wgRunning = true; wgStatusEl.textContent = 'activo';
      console.log('WebGazer started');
    }catch(e){
      alert('No se pudo iniciar WebGazer: ' + e.message);
      console.error(e);
    }
  });

  document.getElementById('stopWG').addEventListener('click', ()=>{
    try{
      webgazer.end(); // stops and removes video canvas
    }catch(e){}
    wgRunning = false; wgStatusEl.textContent = 'detenido';
    latestGaze = null;
  });

  // Open external calibration demo in new tab (user calibrates there)
  document.getElementById('openCalib').addEventListener('click', ()=>{
    window.open('https://webgazer.cs.brown.edu/calibration.html?#', '_blank');
  });

  // Use saved model (if demo saved to local storage) - approach: webgazer.begin() + it will auto load saved data if saveDataAcrossSessions was true.
  document.getElementById('useSavedModel').addEventListener('click', async ()=>{
    if(!wgRunning){
      alert('Inicia WebGazer primero (Iniciar WebGazer).');
      return;
    }
    // In current WebGazer API begin() will load saved data if available. We can also notify user.
    alert('WebGazer intentará usar datos guardados en el navegador (si existen). Si calibraste en la demo en esta misma máquina/navegador, deberían aplicarse.');
  });

  // ---------- Logging & CSV ----------
  function pushLog(entry){
    // ensure gaze coords and err exist (numbers)
    if(!('gazeX' in entry)) entry.gazeX = Number.isFinite(entry.gazeX)?entry.gazeX:-1;
    if(!('gazeY' in entry)) entry.gazeY = Number.isFinite(entry.gazeY)?entry.gazeY:-1;
    if(!('err' in entry)) entry.err = Number.isFinite(entry.err)?entry.err:-1;
    log.push(entry);
    const la = document.getElementById('logArea');
    const line = `${new Date(entry.t).toISOString()} | tgt:${entry.tgtX?.toFixed(1)||'-'},${entry.tgtY?.toFixed(1)||'-'} | gaze:${entry.gazeX.toFixed(1)},${entry.gazeY.toFixed(1)} | err:${entry.err.toFixed(1)} | success:${entry.success?1:0}`;
    const div = document.createElement('div'); div.textContent = line;
    la.prepend(div);
    if(la.childElementCount>200) la.removeChild(la.lastChild);
  }

  document.getElementById('downloadLog').addEventListener('click', ()=>{
    if(log.length === 0){ alert('No hay datos para descargar'); return; }
    const header = 'timestamp,tgtX,tgtY,gazeX,gazeY,err,headV,eyeV,success\n';
    const rows = log.map(r =>
      `${new Date(r.t).toISOString()},${r.tgtX||''},${r.tgtY||''},${r.gazeX||''},${r.gazeY||''},${r.err||''},${r.headV||''},${r.eyeV||''},${r.success?1:0}`
    ).join('\n');
    const blob = new Blob([header + rows], {type:'text/csv'}), url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'vor_rehab_webgazer_log.csv'; a.click(); URL.revokeObjectURL(url);
  });

  document.getElementById('clearLog').addEventListener('click', ()=>{ log = []; document.getElementById('logArea').innerHTML = ''; });

  // ---------- Exercises control ----------
  document.getElementById('exercise1').addEventListener('click', ()=> startExercise('stabilize'));
  document.getElementById('exercise2').addEventListener('click', ()=> startExercise('moving'));
  document.getElementById('stopExercise').addEventListener('click', ()=> stopExercise());

  function startExercise(name){
    if(!wgRunning){ if(!confirm('WebGazer no está activo. ¿Iniciar WebGazer ahora?')) return; }
    currentExercise = name; exerciseLabel.textContent = name;
    exerciseState = { started: performance.now(), difficulty: 1.0, successBuffer: [] };
    if(name === 'stabilize') {
      exerciseState.tgt = { x: canvas.width*0.5, y: canvas.height*0.45 };
      exerciseState.allowedPx = 70;
    } else if(name === 'moving') {
      exerciseState.tgt = { x: 80, y: canvas.height*0.5 }; exerciseState.dir = 1; exerciseState.speed = 140; exerciseState.allowedPx = 60;
    }
  }
  function stopExercise(){ currentExercise = null; exerciseState = {}; exerciseLabel.textContent = 'ninguno'; }

  // ---------- Drawing loop ----------
  let lastFrame = performance.now();
  function drawLoop(ts){
    const dt = (ts - lastFrame)/1000; lastFrame = ts;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Draw background / HUD minimal
    ctx.fillStyle = '#04121a'; ctx.fillRect(0,0,canvas.width,canvas.height);

    // get gaze coords (webgazer returns window coordinates)
    let gazeX = null, gazeY = null;
    if(latestGaze && typeof latestGaze.x === 'number' && typeof latestGaze.y === 'number'){
      // Map screen coords -> canvas coords (canvas may be different scale)
      // We assume canvas is displayed full in its container; compute bounding client rect mapping
      const rect = canvas.getBoundingClientRect();
      // latestGaze.x/y are relative to page; compute canvas-local coords
      gazeX = (latestGaze.x - rect.left) * (canvas.width / rect.width);
      gazeY = (latestGaze.y - rect.top) * (canvas.height / rect.height);
      if(mirrored) gazeX = canvas.width - gazeX;
      gazePosEl.textContent = `${Math.round(gazeX)}, ${Math.round(gazeY)}`;
    } else {
      gazePosEl.textContent = '-';
    }

    // Draw target(s)
    if(currentExercise === 'stabilize' && exerciseState.tgt){
      // For this simple WebGazer-only version we cannot compute true head velocity (no face mesh),
      // so the target remains static or we can simulate movement by oscillation if desired.
      // We'll keep static and rely on gaze accuracy for rehab training.
      ctx.beginPath(); ctx.fillStyle='rgba(30,200,120,0.95)'; ctx.arc(exerciseState.tgt.x, exerciseState.tgt.y, 18, 0, Math.PI*2); ctx.fill();
    }
    if(currentExercise === 'moving' && exerciseState.tgt){
      // move horizontally
      exerciseState.tgt.x += (exerciseState.dir||1) * (exerciseState.speed||120) * dt;
      if(exerciseState.tgt.x < 40){ exerciseState.tgt.x = 40; exerciseState.dir = 1; }
      if(exerciseState.tgt.x > canvas.width - 40){ exerciseState.tgt.x = canvas.width - 40; exerciseState.dir = -1; }
      ctx.beginPath(); ctx.fillStyle='rgba(90,170,255,0.95)'; ctx.arc(exerciseState.tgt.x, exerciseState.tgt.y, 16, 0, Math.PI*2); ctx.fill();
    }

    // Draw "eye origin" (virtual eye/head) and pointer towards gaze
    const origin = eyeOrigin();
    ctx.beginPath(); ctx.fillStyle='rgba(200,200,200,0.95)'; ctx.arc(origin.x, origin.y, 12, 0, Math.PI*2); ctx.fill();
    ctx.font = '12px monospace'; ctx.fillStyle='#bfe7c8'; ctx.fillText('OJO', origin.x - 18, origin.y + 28);

    if(gazeX !== null){
      // draw small cursor at gaze
      ctx.beginPath(); ctx.fillStyle='rgba(255,255,0,0.95)'; ctx.arc(gazeX, gazeY, 10, 0, Math.PI*2); ctx.fill();

      // draw arrow from origin to gaze
      drawArrow(origin.x, origin.y, gazeX, gazeY);

      // Evaluate success / error if an exercise is active
      if(currentExercise && exerciseState.tgt){
        const dx = gazeX - exerciseState.tgt.x, dy = gazeY - exerciseState.tgt.y;
        const err = Math.hypot(dx, dy);
        const success = err <= exerciseState.allowedPx;
        gazeErrEl.textContent = err.toFixed(1);

        // feedback ring
        ctx.lineWidth = 3;
        ctx.strokeStyle = success ? 'rgba(0,255,120,0.9)' : (err < exerciseState.allowedPx*1.6 ? 'rgba(255,200,0,0.9)' : 'rgba(255,80,80,0.9)');
        ctx.beginPath(); ctx.arc(exerciseState.tgt.x, exerciseState.tgt.y, exerciseState.allowedPx/1.2, 0, Math.PI*2); ctx.stroke();

        // push log sample (time-sampled at frame rate)
        pushLogSample({
          t: Date.now(),
          tgtX: exerciseState.tgt.x,
          tgtY: exerciseState.tgt.y,
          gazeX: gazeX,
          gazeY: gazeY,
          err: err,
          headV: 0,
          eyeV: 0,
          success: success
        });
      } else {
        gazeErrEl.textContent = 'n/a';
      }
    } else {
      gazeErrEl.textContent = '-';
    }

    requestAnimationFrame(drawLoop);
  }

  function drawArrow(x1,y1,x2,y2){
    const dx = x2-x1, dy = y2-y1;
    const angle = Math.atan2(dy,dx);
    const len = Math.hypot(dx,dy);
    const maxLen = Math.min(len, 380);
    // line
    ctx.strokeStyle = 'rgba(255,180,60,0.95)';
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(x1,y1);
    ctx.lineTo(x1 + Math.cos(angle) * maxLen, y1 + Math.sin(angle) * maxLen);
    ctx.stroke();
    // arrowhead
    const ax = x1 + Math.cos(angle) * maxLen;
    const ay = y1 + Math.sin(angle) * maxLen;
    ctx.fillStyle = 'rgba(255,180,60,0.95)';
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax - 12*Math.cos(angle - Math.PI/6), ay - 12*Math.sin(angle - Math.PI/6));
    ctx.lineTo(ax - 12*Math.cos(angle + Math.PI/6), ay - 12*Math.sin(angle + Math.PI/6));
    ctx.closePath();
    ctx.fill();
  }

  // pushLogSample collects a sample but avoids flooding identical entries quickly (frame-rate sampling is fine)
  function pushLogSample(sample){
    // ensure numbers
    sample.gazeX = Number(sample.gazeX) || -1;
    sample.gazeY = Number(sample.gazeY) || -1;
    sample.err = Number(sample.err) || -1;
    sample.t = sample.t || Date.now();
    pushLog(sample);
  }

  // ---------- Start drawing ----------
  requestAnimationFrame(drawLoop);

  // ---------- Cleanup on unload ----------
  window.addEventListener('beforeunload', ()=>{ try{ webgazer.end(); } catch(e){} });

  </script>
</body>
</html>
